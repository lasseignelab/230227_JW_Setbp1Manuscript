---
title: "Setbp1_AmbientRNA_SoupX_02"
author: "Jordan Whitlock"
date: '2023-04-12'
output: html_document
---

# *Single-nuclei analysis: Run SoupX*
* Loading libraries
* Selecting resolution
* Investigating top markers for Kidney Cortex
* ID cell types for SoupX

All resources for running SoupX were found in the following:
* https://github.com/constantAmateur/SoupX
* https://rawcdn.githack.com/constantAmateur/SoupX/204b602418df12e9fdb4b68775a8b486c6504fe4/inst/doc/pbmcTutorial.html
* https://doi.org/10.1093/gigascience/giaa151
* https://zenodo.org/record/6633564/files/SoupX%20AutoEstimate%20all%20datasets.R?download=1

Below code is based off of sample script provided by Dr. Lara Ianov.

This script suceedes Setbp1_CellTypesKidney_SoupX01.Rmd and precedes Setbp1_QC_post_01.Rmd. 

# Overview:
* Ambient RNA removal with `SoupX` with object which contains seurat clusters (`cell_type`) - does not need to have clusters annotated with cell name, but cluster should be of high confidence (see note), therefore annotated clusters were used in this analysis for SoupX.

NOTE: this approach is more conservative than the standard SoupX processing as we use seurat clusters from the integrated object. It's possible that in the future we will switch to just using the 10X clusters auto-generated by CellRanger, but for now (until we properly benchmark/compare) this more conservative approach is applied.

# Setup 
```{r load-libraries, message=FALSE}
set.seed(2178)
library(Seurat)
library(SoupX)
library(dplyr)
library(AnnotationHub)
library(ggplot2)
library(here)
library(styler)
library(lintr)
```


# Import pre-annotated and processed object
While `SoupX` allows users to import clusters from 10X `cellranger` runs, I have decided to use the `cell_type` suerat clusters instead for a more sensitive analysis. While this prolongs the overall workflow, it is likely that the clusters may be more well defined than `cellranger` (in the future U-BDS will benchmark analysis with this workflow vs 10X `cellranger` cluster to quantify how efficiently the 10X cluster can be used for ambient RNA removal. However, until that time, I have chosen this more conservative approach).
Since `SoupX` works with the filtered and raw matrices, the object of choice which contains clusters defined is `.kidney_int_celltypes.Rdata`

```{r load-annotated-object}
load(here("data/kidney_integrated_celltypes.Rdata"))
```

# SoupX workflow
## Prepare initial metadata
Using the pre-processed object, we create a data.frame per sample which contains cell names (original names, thus need to remove suffix Seurat adds) as row names and `cell_type` as metadata to be provided to `SoupX`
```{r prepare-metadata-from-annotated}
metadata_original_obj <- kidney_int_celltypes@meta.data
#add cell names as a column and remove suffix for now to match
metadata_original_obj$cell_names <- rownames(metadata_original_obj)
metadata_original_obj$cell_names <- sub("*._","", metadata_original_obj$cell_names) %>% sub("^[^_]*_", "", .)
#add cluster annotation to seurat_cluster to ensure mapping later
metadata_original_obj$cluster_num <-  metadata_original_obj$seurat_clusters
metadata_original_obj$seurat_clusters <-  metadata_original_obj$cell_type
# make list to subset by id- again following the same sample order of original object
metadata_original_obj_subset <- list(K1 = subset(metadata_original_obj, orig.ident == "K1"),
                                    K2 = subset(metadata_original_obj, orig.ident == "K2"),
                                    K3 = subset(metadata_original_obj, orig.ident == "K3"),
                                    K4 = subset(metadata_original_obj, orig.ident == "K4"),
                                    K5 = subset(metadata_original_obj, orig.ident == "K5"),
                                    K6 = subset(metadata_original_obj, orig.ident == "K6"))



lapply(X = metadata_original_obj_subset, FUN = function(x) {
  head(x)
 })

#check size of newly made list against known cell number for each sample (numbers should match)
table(kidney_int_celltypes$orig.ident)
```
   K1    K2    K3    K4    K5    K6 
13548 19218 11294 11541 13955 12760 


## Import secondary analysis outputs
Read in both the RAW and FILTERED Outputs from CellRanger
```{r, eval=FALSE}
h5_files_filtered <- sort(paste0(list.dirs("/data/project/lasseigne_lab/JordanWhitlock/jw_setbp1/introns_processed_data", recursive = FALSE),"/outs/filtered_feature_bc_matrix.h5"))
h5_files_filtered <- h5_files_filtered[7:12] #grabbing only kidney
h5_files_filtered # example: "/data/project/lasseigne_lab/JordanWhitlock/jw_setbp1/introns_processed_data/K1/outs/filtered_feature_bc_matrix.h5"
h5_files_raw <- sort(paste0(list.dirs("/data/project/lasseigne_lab/JordanWhitlock/jw_setbp1/introns_processed_data", recursive = FALSE),"/outs/raw_feature_bc_matrix.h5"))
h5_files_raw <- h5_files_raw[7:12]
h5_files_raw # example: "/data/project/lasseigne_lab/JordanWhitlock/jw_setbp1/introns_processed_data/K1/outs/raw_feature_bc_matrix.h5"
# Read 10X hdf5 files
N_objs_counts_filtered <- lapply(setNames(h5_files_filtered,
                                         make.names(c("K1", "K2", "K3", "K4", "K5", "K6"))),
                                Read10X_h5)
N_objs_counts_raw <- lapply(setNames(h5_files_raw,
                                    make.names(c("K1", "K2", "K3", "K4", "K5", "K6"))),
                           Read10X_h5)
```

## Create the 'SoupChannel' objects
```{r, eval=FALSE}
sc_objs <- mapply(FUN = function(x,y) {
  sc_obj <- SoupChannel(
   tod = x, # droplets/raw
   toc = y, # cells/filtered
   calcSoupProfile = TRUE)
  return(sc_obj)
 }, x=N_objs_counts_raw, y=N_objs_counts_filtered, SIMPLIFY = FALSE)
```

## Format metadata for 'SoupX'
Add `cell_type` metadata to the "SoupChannel" objects. Note, however, that all cells __must__ be present in the input metadata, thus some data-wrangling is performed from the `sc_objs` metadata to add any cells that were dropped during the pre-processing under the "cell_dropped" cluster name. 
```{r}
sc_metadata <- mapply(FUN = function(x,y) {
  # from the sc object, create a new metadata obj since it contains all original cells, and merge with
 # the existing metadata (this will account for any dropped cells falling under NA cluster)
  sc_meta <- x$metaData
  # add a new variable with the same variable name from seurat object meta which contains cell_names
  sc_meta$cell_names <- rownames(sc_meta)
  # merge with original meta to retain cells lost during pre-processing
 merged_meta <- merge(x = sc_meta, y = y, by = "cell_names", all = TRUE) # `all` to not drop cells
  # replace NA with unassigned (SoupX does not allow NA)
  merged_meta$seurat_clusters <- as.character(merged_meta$seurat_clusters)
 merged_meta %>%
   mutate(seurat_clusters = tidyr::replace_na(seurat_clusters, "cell_droped")) %>%
   {.} -> merged_meta
  
 return(merged_meta)
 }, x=sc_objs, y=metadata_original_obj_subset, SIMPLIFY = FALSE)
```


```{r}
# a quick peek at the metadata
lapply(X = sc_metadata, FUN = function(x) {
  
   head(x)
  
})
```


## Main SoupX workflow steps
Now add metadata, adjustcounts for ambient RNAs and acquire new filtered counts to be used for downstream analysis
```{r soupx-workflow}
# N_objs_counts are the new filtered and RNA ambient corrected counts
N_objs_counts <- mapply(FUN = function(x,y) {
  sc <- setClusters(x, clusters = setNames(y$seurat_clusters, rownames(y)))
  sc <- autoEstCont(sc)
  # Correcting expression profile
 # round to not have issues with downstream analysis such as pseudobulk etc.
 out_counts <- adjustCounts(sc, roundToInt = TRUE)
  return(out_counts)
 }, x=sc_objs, y=sc_metadata, SIMPLIFY = FALSE)
```
1618 genes passed tf-idf cut-off and 198 soup quantile filter.  Taking the top 100.
Using 390 independent estimates of rho.
Estimated global rho of 0.18
Warning in sparseMatrix(i = out@i[w] + 1, j = out@j[w] + 1, x = out@x[w],  :
  'giveCsparse' is deprecated; setting repr="T" for you
Expanding counts from 18 clusters to 18032 cells.
1100 genes passed tf-idf cut-off and 94 soup quantile filter.  Taking the top 94.
Using 404 independent estimates of rho.
Estimated global rho of 0.24
Warning in sparseMatrix(i = out@i[w] + 1, j = out@j[w] + 1, x = out@x[w],  :
  'giveCsparse' is deprecated; setting repr="T" for you
Expanding counts from 18 clusters to 19556 cells.
1411 genes passed tf-idf cut-off and 143 soup quantile filter.  Taking the top 100.
Using 463 independent estimates of rho.
Estimated global rho of 0.12
Warning in sparseMatrix(i = out@i[w] + 1, j = out@j[w] + 1, x = out@x[w],  :
  'giveCsparse' is deprecated; setting repr="T" for you
Expanding counts from 18 clusters to 14723 cells.
2074 genes passed tf-idf cut-off and 196 soup quantile filter.  Taking the top 100.
Using 390 independent estimates of rho.
Estimated global rho of 0.15
Warning in sparseMatrix(i = out@i[w] + 1, j = out@j[w] + 1, x = out@x[w],  :
  'giveCsparse' is deprecated; setting repr="T" for you
Expanding counts from 18 clusters to 15545 cells.
1368 genes passed tf-idf cut-off and 111 soup quantile filter.  Taking the top 100.
Using 353 independent estimates of rho.
Estimated global rho of 0.15
Warning in sparseMatrix(i = out@i[w] + 1, j = out@j[w] + 1, x = out@x[w],  :
  'giveCsparse' is deprecated; setting repr="T" for you
Expanding counts from 18 clusters to 16393 cells.
1177 genes passed tf-idf cut-off and 150 soup quantile filter.  Taking the top 100.
Using 352 independent estimates of rho.
Estimated global rho of 0.13
Warning in sparseMatrix(i = out@i[w] + 1, j = out@j[w] + 1, x = out@x[w],  :
  'giveCsparse' is deprecated; setting repr="T" for you
Expanding counts from 18 clusters to 15232 cells.

```{r, save-soupx, eval=FALSE}
save(N_objs_counts, file = here("results/seurat/SoupX/setbp1_soupx_ambientRNA_corrected_matrix.Rdata"))
```


# Create new Seurat objects from SoupX counts
Now, re-start the standard workflow, but with `SoupX` counts
Create Seurat objects with RNA assay:
```{r, eval=FALSE}
N_objs <- mapply(FUN = function(x,p) {
 seurat_obj <- CreateSeuratObject(
   counts = x,
   assay = "RNA",
   min.cells = 1,
   min.features = 1,
   project = p)
  return(seurat_obj)
}, x=N_objs_counts, p=names(N_objs_counts))
```


```{r, save-soupx, eval=FALSE}
save(N_objs, file = here("results/seurat/SoupX/setbp1_soupx_ambientRNA_corrected_seurat.Rdata"))
```

Next all the normal seurat processing pipeline steps should be re-run on the N_objs seurat object (QC, Integration, Clustering, Markers, Cell Type Annotation, DGE, and Pathway analysis prior to running PANDA jobs). 

```{r}
proc.time()
```
    user   system  elapsed 
 840.519   95.983 4424.939 
 
```{r}
sessionInfo()
```
 R version 4.1.3 (2022-03-10)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.5 LTS

Matrix products: default
BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] lintr_3.0.2         styler_1.9.0        here_1.0.1          ggplot2_3.4.1       AnnotationHub_3.2.2 BiocFileCache_2.2.1 dbplyr_2.3.1       
 [8] BiocGenerics_0.40.0 dplyr_1.1.0         SoupX_1.6.2         SeuratObject_4.1.3  Seurat_4.3.0       

loaded via a namespace (and not attached):
  [1] plyr_1.8.8                    igraph_1.4.1                  lazyeval_0.2.2                sp_1.6-0                      splines_4.1.3                
  [6] listenv_0.9.0                 scattermore_0.8               GenomeInfoDb_1.30.1           digest_0.6.31                 htmltools_0.5.4              
 [11] fansi_1.0.4                   magrittr_2.0.3                memoise_2.0.1                 tensor_1.5                    cluster_2.1.2                
 [16] ROCR_1.0-11                   remotes_2.4.2                 globals_0.16.2                Biostrings_2.62.0             matrixStats_0.63.0           
 [21] R.utils_2.12.2                spatstat.sparse_3.0-0         colorspace_2.1-0              blob_1.2.3                    rappdirs_0.3.3               
 [26] ggrepel_0.9.3                 xfun_0.37                     callr_3.7.3                   crayon_1.5.2                  RCurl_1.98-1.10              
 [31] jsonlite_1.8.4                progressr_0.13.0              spatstat.data_3.0-0           survival_3.3-1                zoo_1.8-11                   
 [36] glue_1.6.2                    polyclip_1.10-4               gtable_0.3.1                  zlibbioc_1.40.0               XVector_0.34.0               
 [41] leiden_0.4.3                  R.cache_0.16.0                future.apply_1.10.0           abind_1.4-5                   scales_1.2.1                 
 [46] DBI_1.1.3                     spatstat.random_3.1-3         miniUI_0.1.1.1                Rcpp_1.0.10                   viridisLite_0.4.1            
 [51] xtable_1.8-4                  reticulate_1.28               bit_4.0.5                     stats4_4.1.3                  rex_1.2.1                    
 [56] htmlwidgets_1.6.1             httr_1.4.5                    RColorBrewer_1.1-3            ellipsis_0.3.2                ica_1.0-3                    
 [61] R.methodsS3_1.8.2             pkgconfig_2.0.3               uwot_0.1.14                   deldir_1.0-6                  utf8_1.2.3                   
 [66] tidyselect_1.2.0              rlang_1.0.6                   reshape2_1.4.4                later_1.3.0                   AnnotationDbi_1.56.2         
 [71] munsell_0.5.0                 BiocVersion_3.14.0            tools_4.1.3                   cachem_1.0.7                  cli_3.6.0                    
 [76] generics_0.1.3                RSQLite_2.3.0                 ggridges_0.5.4                evaluate_0.20                 stringr_1.5.0                
 [81] fastmap_1.1.1                 yaml_2.3.7                    goftest_1.2-3                 processx_3.8.0                knitr_1.42                   
 [86] bit64_4.0.5                   fitdistrplus_1.1-8            purrr_1.0.1                   RANN_2.6.1                    KEGGREST_1.34.0              
 [91] pbapply_1.7-0                 future_1.31.0                 nlme_3.1-155                  mime_0.12                     R.oo_1.25.0                  
 [96] xml2_1.3.3                    hdf5r_1.3.8                   compiler_4.1.3                rstudioapi_0.14               plotly_4.10.1                
[101] filelock_1.0.2                curl_5.0.0                    png_0.1-8                     interactiveDisplayBase_1.32.0 spatstat.utils_3.0-1         
[106] tibble_3.1.8                  stringi_1.7.12                ps_1.7.2                      cyclocomp_1.1.0               desc_1.4.2                   
[111] lattice_0.20-45               Matrix_1.5-3                  vctrs_0.5.2                   pillar_1.8.1                  lifecycle_1.0.3              
[116] BiocManager_1.30.20           spatstat.geom_3.0-6           lmtest_0.9-40                 RcppAnnoy_0.0.20              data.table_1.14.8            
[121] cowplot_1.1.1                 bitops_1.0-7                  irlba_2.3.5.1                 httpuv_1.6.9                  patchwork_1.1.2              
[126] R6_2.5.1                      promises_1.2.0.1              KernSmooth_2.23-20            gridExtra_2.3                 IRanges_2.28.0               
[131] parallelly_1.34.0             codetools_0.2-18              MASS_7.3-55                   rprojroot_2.0.3               withr_2.5.0                  
[136] sctransform_0.3.5             S4Vectors_0.32.4              GenomeInfoDbData_1.2.7        parallel_4.1.3                grid_4.1.3                   
[141] tidyr_1.3.0                   rmarkdown_2.20                Rtsne_0.16                    spatstat.explore_3.0-6        Biobase_2.54.0               
[146] shiny_1.7.4                  
