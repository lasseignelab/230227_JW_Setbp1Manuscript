---
title: "Setbp1_DoubletFinder_02"
author: "Jordan Whitlock"
date: '2022-09-06'
output:     
  html_document:
      toc: true
      toc_depth: 2
      toc_float: true
---
# *Single-nuclei analysis: Identifying and removing doublets*
* load in seurat object
* split objects by origin ident for each tissue
* calculate optimal pK
* visualize pk distribution
* calculated predicted doublets/multiplets
* remove doublets
* save new object 

## Code: 

Accompanying dry lab notebook for this analysis is here: https://docs.google.com/document/d/1FO_Je9oxbBFF9S_k-8tVF2t4ba88O4C77sw1v7DIFec/edit?usp=sharing

THIS ANALYSIS PAIRS WITH THE 'Setbp1_QC_01.Rmd'
*set the libPaths to: "/Library/Frameworks/R.framework/Versions/4.0/Resources/library"

```{r}
library(Seurat)
library(cowplot)
library(DoubletFinder)
library(here)
library(styler)
library(lintr)
set.seed(2178)
source(here("src/functions/functions.R"))
```

Can pick up analysis from here. Note this data is just filtered for nCount_RNA, mitochondria, and Malat1. No normalization or scaling has taken place. 
```{r}
load(here("data/filtered_setbp1_kidney_seurat.Rdata"))
load(here("data/filtered_setbp1_cerebral_seurat.Rdata"))
```

(from this resource https://nbisweden.github.io/workshop-scRNAseq/labs/compiled/seurat/seurat_01_qc.html#Predict_doublets)

Do not apply DoubletFinder to aggregated scRNA-seq data representing multiple distinct samples (e.g., multiple 10X lanes). For example, if you run DoubletFinder on aggregated data representing WT and mutant cell lines sequenced across different 10X lanes, artificial doublets will be generated from WT and mutant cells, which cannot exist in your data.
```{r}
split_sample <- SplitObject(kidney_seurat_filtered, split.by = "orig.ident")
```

Before doing doublet detection we need to run scaling, variable gene selection and pca, as well as UMAP for visualization. 
```{r}
for (i in 1:length(split_sample)) {
    split_sample[[i]] <- NormalizeData(split_sample[[i]], verbose = FALSE)
    split_sample[[i]] <- FindVariableFeatures(split_sample[[i]],
                                              selection.method = "vst",
                                              nfeatures = 4000,
                                              verbose = FALSE)
    split_sample[[i]] <- ScaleData(split_sample[[i]],
                                vars.to.regress = c("percent_mito", "nFeature_RNA"),
                                assay = "RNA")
    split_sample[[i]] <- RunPCA(split_sample[[i]],
                                verbose = FALSE,
                                npcs = 30, 
                                approx = FALSE) #make sure this matches the RunUMAP below
    split_sample[[i]] <- RunUMAP(split_sample[[i]],
                                verbose = FALSE,
                                dims = 1:30) #make sure this matches the RunPCA npcs
}
```

```{r save-intermediary-object}
save(split_sample, file = here("data/split_sample_kidney.Rdata"))
```


Then detect doublets:  

In order to detect doublets, one must know the predicted number of doublets expected based on the number of nuclei that were recovered. In order to calculate the predicted number of multiplets for your data, see the table here: https://nbisweden.github.io/workshop-scRNAseq/labs/compiled/seurat/seurat_01_qc.html#Predict_doublets

For the kidney, doublets were estimated as follows:
* K1 - 13548 nuclei recovered; ~10.2% doublets
* K2 - 19218 nuclei recovered; ~14.6% doublets
* K3 - 11294 nuclei recovered; ~8.6% doublets
* K4 - 11541 nuclei recovered; ~8.8% doublets
* K5 - 13955 nuclei recovered; ~10.6% doublets
* K6 - 12760 nuclei recovered; ~9.7% doublets

DoubletFinder takes the following arguments:
* seu ~ This is a fully-processed Seurat object (i.e., after NormalizeData, FindVariableGenes, ScaleData, RunPCA, and RunUMAP have all been run).

* PCs ~ The number of statistically-significant principal components, specified as a range (e.g., PCs = 1:10)

*pN ~ This defines the number of generated artificial doublets, expressed as a proportion of the merged real-artificial data. Default is set to 25%, based on observation that DoubletFinder performance is largely pN-invariant (see McGinnis, Murrow and Gartner 2019, Cell Systems).

* pK ~ This defines the PC neighborhood size used to compute pANN, expressed as a proportion of the merged real-artificial data. No default is set, as pK should be adjusted for each scRNA-seq dataset. Optimal pK values should be estimated using the strategy described below. The optimal pK value is the maxima in the BCmvn distribution when using the find.pk function!!! For each sample I have a plotting function that will highlight the maxima in red (source: https://rdrr.io/github/chris-mcginnis-ucsf/DoubletFinder/man/find.pK.html). 
    **considerations to think about when deciding pK:The key to determining which pK to use / whether the pK value is too high requires actually looking at your data. Assuming you know which cell states are present in your system and, thus, which clusters have the potential to be doublets, does using the suggested pK value pick out these clusters? Conversely, does the suggested pK value classify cells as doublets that are part of a cluster that you are very confident are singlets?

*nExp ~ This defines the pANN threshold used to make final doublet/singlet predictions. This value can best be estimated from cell loading densities into the 10X/Drop-Seq device, and adjusted according to the estimated proportion of homotypic doublets.

```{r definepK-kidney}
pdf(here("results/seurat/DoubletFinder_02/definepK_kidney.pdf"))
#K1
define_pK_noapprox(split_sample$K1)

#K2
define_pK_noapprox(split_sample$K2)

#K3
define_pK_noapprox(split_sample$K3)

#K4
define_pK_noapprox(split_sample$K4)

#K5
define_pK_noapprox(split_sample$K5)

#K6
define_pK_noapprox(split_sample$K6)
dev.off()
```

```{r remove-doublets-kidney}
pdf(filename = here("results/seurat/DoubletFinder_02/doubletsremoved_kidney.pdf"))

#K1
doublet_removal_noapprox(sample = split_sample$K1, expected = 0.102, pK = 0.01) #pK obtained from plot in line above
split_sample$K1 <- no_doublets

#K2
doublet_removal_noapprox(sample = split_sample$K2, expected = 0.146, pK = 0.14) #pK obtained from plot in line above
split_sample$K2 <- no_doublets

#K3
doublet_removal_noapprox(sample = split_sample$K3, expected = 0.086, pK = 0.005) #pK obtained from plot in line above
split_sample$K3 <- no_doublets

#K4
doublet_removal_noapprox(sample = split_sample$K4, expected = 0.088, pK = 0.005) #pK obtained from plot in line above
split_sample$K4 <- no_doublets

#K5
doublet_removal_noapprox(sample = split_sample$K5, expected = 0.106, pK = 0.005) #pK obtained from plot in line above
split_sample$K5 <- no_doublets

#K6
doublet_removal_noapprox(sample = split_sample$K6, expected = 0.097, pK = 0.005) #pK obtained from plot in line above
split_sample$K6 <- no_doublets

dev.off()
```

# Merge seurat object that has no doublets now:
```{r}
kidney_seurat_filtered <- merge(
  x = split_sample$K1,
  y = c(
    split_sample$K2, 
    split_sample$K3, 
    split_sample$K4, 
    split_sample$K5, 
    split_sample$K6
  )
)

save(kidney_seurat_filtered, 
     file = here("data/nodoublet_setbp1_kidney_seurat.Rdata"))
```

-------------------------------------------------------------------

```{r}
split_sample <- SplitObject(cerebral_seurat_filtered, split.by = "orig.ident")
```

Before doing doublet detection we need to run scaling, variable gene selection and pca, as well as UMAP for visualization.
```{r}
for (i in 1:length(split_sample)) {
    split_sample[[i]] <- NormalizeData(split_sample[[i]], verbose = FALSE)
    split_sample[[i]] <- FindVariableFeatures(split_sample[[i]], 
                                              selection.method = "vst",
                                              nfeatures = 4000, 
                                              verbose = FALSE)
    split_sample[[i]] <- ScaleData(split_sample[[i]], 
                                   vars.to.regress = c("percent_mito", "nFeature_RNA"), 
                                   assay = "RNA")
    split_sample[[i]] <- RunPCA(split_sample[[i]], 
                                verbose = FALSE, 
                                npcs = 30,
                                approx = FALSE)
    split_sample[[i]] <- RunUMAP(split_sample[[i]], 
                                 verbose = FALSE, 
                                 dims = 1:30)
}
```

```{r save-intermediary-object}
save(split_sample, file = here("data/split_sample_cortex.Rdata"))
```

Then detect doublets: 
For the kidney, doublets were estimated as follows:
* J1 - 5023 nuclei recovered; ~4% doublets
* J2 - 7070 nuclei recovered; ~5.4% doublets
* J3 - 10333 nuclei recovered; ~7.8% doublets
* J4 - 10417 nuclei recovered; ~7.9% doublets
* J13 - 9343 nuclei recovered; ~7.1% doublets
* J15 - 8852 nuclei recovered; ~6.7% doublets

```{r define-pK-doublets-cortex}
pdf(filename = here("results/seurat/DoubletFinder_02/definepK_cortex.pdf"))

#J1
define_pK_noapprox(split_sample$J1)

#J2
define_pK_noapprox(split_sample$J2)

#J3
define_pK_noapprox(split_sample$J3)

#J4
define_pK_noapprox(split_sample$J4)

#J13
define_pK_noapprox(split_sample$J13)

#J15
define_pK_noapprox(split_sample$J15)

dev.off()
```

```{r remove-doublets-cortex}
pdf(filename = here("results/seurat/DoubletFinder_02/doubletsremoved_cortex.pdf"))
#J1
doublet_removal_noapprox(sample = split_sample$J1, expected = 0.04, pK = 0.3) #pK obtained from plot in line above
split_sample$J1 <- no_doublets

#J2
doublet_removal_noapprox(sample = split_sample$J2, expected = 0.054, pK = 0.3) #pK obtained from plot in line above
split_sample$J2 <- no_doublets

#J3
doublet_removal_noapprox(sample = split_sample$J3, expected = 0.078, pK = 0.19) #pK obtained from plot in line above
split_sample$J3 <- no_doublets

#J4
doublet_removal_noapprox(sample = split_sample$J4, expected = 0.079, pK = 0.16) #pK obtained from plot in line above
split_sample$J4 <- no_doublets

#J13
doublet_removal_noapprox(sample = split_sample$J13, expected = 0.071, pK = 0.25) #pK obtained from plot in line above
split_sample$J13 <- no_doublets

#J15
doublet_removal_noapprox(sample = split_sample$J15, expected = 0.067, pK = 0.23) #pK obtained from plot in line above
split_sample$J15 <- no_doublets

dev.off()
```

# Merge seurat object that has no doublets now:
```{r}
cerebral_seurat_filtered <- merge(
  x = split_sample$J1, 
  y = c(
    split_sample$J2, 
    split_sample$J3, 
    split_sample$J4, 
    split_sample$J13, 
    split_sample$J15
  )
)

save(cerebral_seurat_filtered, 
     file = here("data/nodoublet_setbp1_cerebral_seurat.Rdata")
)
```

```{r}
sessionInfo()
```
R version 4.1.3 (2022-03-10)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.5 LTS

Matrix products: default
BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] ggplot2_3.4.1       lintr_3.0.2         styler_1.9.0        here_1.0.1          DoubletFinder_2.0.3 cowplot_1.1.1       SeuratObject_4.1.3 
[8] Seurat_4.3.0       

loaded via a namespace (and not attached):
  [1] Rtsne_0.16             colorspace_2.1-0       deldir_1.0-6           ellipsis_0.3.2         ggridges_0.5.4         rprojroot_2.0.3       
  [7] rstudioapi_0.14        spatstat.data_3.0-0    leiden_0.4.3           listenv_0.9.0          remotes_2.4.2          ggrepel_0.9.3         
 [13] fansi_1.0.4            xml2_1.3.3             codetools_0.2-18       splines_4.1.3          R.methodsS3_1.8.2      knitr_1.42            
 [19] polyclip_1.10-4        jsonlite_1.8.4         ica_1.0-3              cluster_2.1.2          png_0.1-8              R.oo_1.25.0           
 [25] uwot_0.1.14            shiny_1.7.4            sctransform_0.3.5      spatstat.sparse_3.0-0  compiler_4.1.3         httr_1.4.5            
 [31] Matrix_1.5-3           fastmap_1.1.1          lazyeval_0.2.2         cli_3.6.0              later_1.3.0            htmltools_0.5.4       
 [37] tools_4.1.3            igraph_1.4.1           gtable_0.3.1           glue_1.6.2             RANN_2.6.1             reshape2_1.4.4        
 [43] dplyr_1.1.0            Rcpp_1.0.10            scattermore_0.8        vctrs_0.5.2            spatstat.explore_3.0-6 nlme_3.1-155          
 [49] progressr_0.13.0       lmtest_0.9-40          spatstat.random_3.1-3  xfun_0.37              stringr_1.5.0          ps_1.7.2              
 [55] globals_0.16.2         mime_0.12              miniUI_0.1.1.1         lifecycle_1.0.3        irlba_2.3.5.1          goftest_1.2-3         
 [61] future_1.31.0          MASS_7.3-55            zoo_1.8-11             scales_1.2.1           promises_1.2.0.1       spatstat.utils_3.0-1  
 [67] rex_1.2.1              parallel_4.1.3         RColorBrewer_1.1-3     reticulate_1.28        pbapply_1.7-0          gridExtra_2.3         
 [73] stringi_1.7.12         desc_1.4.2             cyclocomp_1.1.0        rlang_1.0.6            pkgconfig_2.0.3        matrixStats_0.63.0    
 [79] lattice_0.20-45        ROCR_1.0-11            purrr_1.0.1            tensor_1.5             patchwork_1.1.2        htmlwidgets_1.6.1     
 [85] processx_3.8.0         tidyselect_1.2.0       parallelly_1.34.0      RcppAnnoy_0.0.20       plyr_1.8.8             magrittr_2.0.3        
 [91] R6_2.5.1               generics_0.1.3         withr_2.5.0            pillar_1.8.1           fitdistrplus_1.1-8     survival_3.3-1        
 [97] abind_1.4-5            sp_1.6-0               tibble_3.1.8           future.apply_1.10.0    crayon_1.5.2           KernSmooth_2.23-20    
[103] utf8_1.2.3             spatstat.geom_3.0-6    plotly_4.10.1          grid_4.1.3             data.table_1.14.8      callr_3.7.3           
[109] digest_0.6.31          xtable_1.8-4           R.cache_0.16.0         tidyr_1.3.0            httpuv_1.6.9           R.utils_2.12.2        
[115] munsell_0.5.0          viridisLite_0.4.1

```{r}
# run style
style_file(here("src/seurat_scripts/Setbp1_QC_01.Rmd"))
# lintr was run as well
```

This script is followed by 'Setbp1_integration_03.Rmd'
